import gleam/io
import gleam/string
import gleam/list
import gleam/result
import gleam/regex
import gleam/int
import gleam/option.{type Option, Some}
import simplifile

fn wanted_function(line: String) -> Bool {
  [
    "InitWindow", "SetTargetFPS", "WindowShouldClose", "CloseWindow",
    "BeginDrawing", "EndDrawing", "ClearBackground", "DrawText", "DrawCircle",
    "DrawCircleV", "GetMouseX", "GetMouseY",
  ]
  |> list.map(fn(name) { " " <> name <> "(" })
  |> list.any(fn(function_name) { string.contains(line, function_name) })
}

type ReturnType {
  ReturnVoid
  ReturnInt
  ReturnBool
  ReturnUnknown(name: String)
}

type FunctionDefinition {
  FunctionDefinition(
    name: String,
    return_type: ReturnType,
    argc: Int,
    argv: List(ArgumentDefinition),
  )
}

type ArgumentDefinition {
  ArgumentDefinition(name: String, arg_type: ArgumentType)
}

type ArgumentType {
  ArgVoid
  ArgInt
  ArgFloat
  ArgUnknown
  ArgConstCharPointer
  ArgColor
  ArgVector2
}

pub fn main() {
  let assert Ok(str) = simplifile.read("c_src/raylib.h")
  let functions = get_api_functions(str)

  io.debug(functions)

  let gleam_file = generate_ffi_gleam(functions)
  let assert Ok(Nil) = simplifile.write("src/raylib.gleam", gleam_file)

  let erl_file = generate_ffi_erl(functions)
  let assert Ok(Nil) = simplifile.write("src/raylib_ffi.erl", erl_file)

  let cpp_file = generate_ffi_cpp(functions)
  let assert Ok(Nil) = simplifile.write("src/raylib_ffi.cpp", cpp_file)
}

fn generate_ffi_erl(functions: List(FunctionDefinition)) -> String {
  let exports =
    functions
    |> list.map(function_to_erlang_signature)
    |> string.join(",\n")

  let function_stubs =
    functions
    |> list.map(function_to_erlang_stub)
    |> string.join("\n\n")

  "
%
% File generated by generate_bindings.gleam.
%

-module(raylib_ffi).
-on_load(init/0).
-export([
  init/0,
" <> exports <> "
]).
-nifs([
" <> exports <> "
]).

init() ->
	erlang:load_nif(\"raylib_ffi\", 0).

" <> function_stubs
}

fn generate_ffi_gleam(functions: List(FunctionDefinition)) -> String {
  let function_stubs =
    functions
    |> list.map(function_to_gleam_definition)
    |> string.join("\n\n")

  "
//
// File generated by generate_bindings.gleam.
//

import gleam/erlang/charlist

pub type Vector2 {
  Vector2(x: Int, y: Int)
}

pub type Color = Int

" <> function_stubs
}

fn generate_ffi_cpp(functions: List(FunctionDefinition)) -> String {
  let exports =
    functions
    |> list.map(fn(function) {
      let fn_name = camel_case_to_snake_case(function.name)

      "{ \""
      <> fn_name
      <> "\", "
      <> int.to_string(function.argc)
      <> ", "
      <> fn_name
      <> " }"
    })
    |> string.join(",\n")

  let function_defs =
    functions
    |> list.map(cpp_function_def)
    |> string.join("\n\n")

  "
//
// File generated by generate_bindings.gleam.
//

#include <erl_nif.h>
#include <iostream>
#include <raylib.h>

" <> function_defs <> "

static ErlNifFunc nif_funcs[] =
{
" <> exports <> "
};

ERL_NIF_INIT(raylib_ffi, nif_funcs, NULL, NULL, NULL, NULL)
"
}

fn arg_to_cpp(arg: ArgumentDefinition, index: Int) -> String {
  let var_name = "arg" <> int.to_string(index)
  case arg.arg_type {
    ArgInt -> "int " <> var_name <> ";
      enif_get_int(env, argv[" <> int.to_string(index) <> "], &" <> var_name <> ");"
    ArgConstCharPointer -> "char " <> var_name <> "[1024];
    if (!enif_get_string(env, argv[" <> int.to_string(index) <> "], " <> var_name <> ", sizeof(" <> var_name <> "), ERL_NIF_UTF8))
    {
      return enif_make_badarg(env);
    }"
    ArgColor -> "unsigned int tmp_" <> var_name <> ";
      enif_get_uint(env, argv[" <> int.to_string(index) <> "], &tmp_" <> var_name <> ");
      Color " <> var_name <> " = GetColor(tmp_" <> var_name <> ");"
    ArgFloat -> "double " <> var_name <> ";
      enif_get_double(env, argv[" <> int.to_string(index) <> "], &" <> var_name <> ");"
    ArgVoid -> ""
    ArgVector2 -> {
      let tmp_var_name = "tmp_arg" <> int.to_string(index)
      "
    const ERL_NIF_TERM* " <> tmp_var_name <> ";
    int arity" <> int.to_string(index) <> ";
    enif_get_tuple(env, argv[0], &arity" <> int.to_string(index) <> ", &" <> tmp_var_name <> ");
    int " <> tmp_var_name <> "_x;
    enif_get_int(env, " <> tmp_var_name <> "[1], &" <> tmp_var_name <> "_x);
    int " <> tmp_var_name <> "_y;
    enif_get_int(env, " <> tmp_var_name <> "[2], &" <> tmp_var_name <> "_y);
    Vector2 " <> var_name <> ";
    " <> var_name <> ".x = " <> tmp_var_name <> "_x;
    " <> var_name <> ".y = " <> tmp_var_name <> "_y;"
    }
    ArgUnknown -> panic as "ArgUnknown not implemented"
  }
}

fn cpp_function_def(function: FunctionDefinition) -> String {
  let fn_name = camel_case_to_snake_case(function.name)

  let args =
    function.argv
    |> list.index_map(arg_to_cpp)
    |> string.join("\n")
    <> "\n"

  let args_names =
    function.argv
    |> list.index_map(fn(_, index) { "arg" <> int.to_string(index) })
    |> string.join(", ")

  let function_call = function.name <> "(" <> args_names <> ");"

  let body = case function.return_type {
    ReturnVoid -> args <> function_call <> "\nreturn enif_make_int(env, 0);"
    ReturnInt ->
      args
      <> "int result = "
      <> function_call
      <> "\nreturn enif_make_int(env, result);"
    ReturnBool ->
      args
      <> "unsigned int result = "
      <> function_call
      <> "\nreturn enif_make_uint(env, result);"
    ReturnUnknown(err) -> panic as err
  }

  "static ERL_NIF_TERM "
  <> fn_name
  <> "(ErlNifEnv *env, int argc, const ERL_NIF_TERM argv[]) {\n"
  <> body
  <> "\n}"
}

fn arg_type_to_string(arg: ArgumentType) -> String {
  case arg {
    ArgInt -> "Int"
    ArgConstCharPointer -> "charlist.Charlist"
    ArgUnknown -> "Nil"
    ArgVoid -> "Nil"
    ArgFloat -> "Float"
    ArgColor -> "Color"
    ArgVector2 -> "Vector2"
  }
}

fn return_type_to_string(t: ReturnType) -> Result(String, String) {
  case t {
    ReturnVoid -> Ok("Nil")
    ReturnInt -> Ok("Int")
    ReturnBool -> Ok("bool")
    ReturnUnknown(err) -> Ok(err)
  }
}

fn function_to_gleam_definition(function: FunctionDefinition) -> String {
  let fn_name = camel_case_to_snake_case(function.name)
  let args =
    function.argv
    |> list.map(fn(arg) {
      camel_case_to_snake_case(arg.name)
      <> ": "
      <> arg_type_to_string(arg.arg_type)
    })
    |> string.join(", ")
  let return_type = case return_type_to_string(function.return_type) {
    Ok(t) -> t
    Error(msg) -> {
      io.debug(function)
      panic as { fn_name <> ": " <> msg }
    }
  }

  "@external(erlang, \"raylib_ffi\", \"" <> fn_name <> "\")
pub fn " <> fn_name <> "(" <> args <> ") -> " <> return_type
}

fn function_to_erlang_stub(function: FunctionDefinition) -> String {
  let args =
    function.argv
    |> list.map(fn(arg) { camel_case_to_snake_case(arg.name) })
    |> string.join(", ")

  camel_case_to_snake_case(function.name)
  <> "("
  <> args
  <> ") -> erlang:nif_error(\"NIF library not loaded\")."
}

fn camel_case_to_snake_case(str: String) -> String {
  str
  |> string.to_graphemes()
  |> list.fold("", fn(acc, next) {
    let last_char_is_lowercase = case string.last(acc) {
      Ok(char) -> char == string.lowercase(char)
      Error(_) -> True
    }

    let next_char_is_lowercase = next == string.lowercase(next)

    case acc, last_char_is_lowercase, next_char_is_lowercase {
      "", _, _ -> acc <> next
      _, True, False -> acc <> "_" <> next
      _, False, False -> acc <> next
      _, _, True -> acc <> next
    }
  })
  |> string.lowercase()
}

fn function_to_erlang_signature(function: FunctionDefinition) -> String {
  camel_case_to_snake_case(function.name) <> "/" <> int.to_string(function.argc)
}

fn get_api_functions(whole_file: String) -> List(FunctionDefinition) {
  let lines =
    whole_file
    |> string.split("\n")
    |> list.filter(fn(line) { string.starts_with(line, "RLAPI") })
    |> list.map(cleanup_line)
    |> list.filter(fn(line) { !string.is_empty(line) })

  let functions =
    lines
    |> list.filter(wanted_function)
    |> list.map(line_to_function_definition)

  functions
}

fn cleanup_line(line: String) -> String {
  line
  |> string.split("//")
  |> list.first
  |> result.unwrap("")
  |> string.trim
}

fn line_to_function_definition(line: String) -> FunctionDefinition {
  let assert Ok(rgx) = regex.from_string("RLAPI (.*) (.*)\\((.*)\\)")
  let assert [match] = regex.scan(rgx, line)
  let assert [Some(return_type), Some(function_name), Some(args)] =
    match.submatches

  let return_type = case string_to_return_type(return_type) {
    Ok(t) -> t
    Error(err) ->
      panic as {
        "Error converting line [" <> line <> "] error: [" <> err <> "]"
      }
  }

  let argv = case args {
    "void" -> []
    _ ->
      args
      |> string.split(",")
      |> list.map(arg_str_to_arg_definition)
  }

  let argc =
    argv
    |> list.length()

  FunctionDefinition(function_name, return_type, argc, argv)
}

fn string_to_return_type(str: String) -> Result(ReturnType, String) {
  case str {
    "void" -> Ok(ReturnVoid)
    "int" -> Ok(ReturnInt)
    "bool" -> Ok(ReturnBool)
    other -> Error("Return type '" <> other <> "' not implemented.")
  }
}

fn arg_str_to_arg_definition(arg: String) -> ArgumentDefinition {
  let arg_type =
    arg
    |> string.trim
    |> detect_argument_type

  let arg_name =
    arg
    |> string.trim
    |> string.split(" ")
    |> list.last
    |> result.unwrap("unnamed_arg")
    |> string.replace("*", "")

  ArgumentDefinition(arg_name, arg_type)
}

fn detect_argument_type(str: String) -> ArgumentType {
  let t =
    [
      #("void", ArgVoid),
      #("const char *", ArgConstCharPointer),
      #("int", ArgInt),
      #("float", ArgFloat),
      #("Color", ArgColor),
      #("Vector2", ArgVector2),
    ]
    |> list.find(fn(t) { string.starts_with(str, t.0) })

  case t {
    Ok(t) -> t.1
    Error(_) -> panic as { "Unknown argument type [" <> str <> "]" }
  }
}
